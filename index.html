<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Solana Neon Spin</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Confetti -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

    <script>
        tailwind.config = {
          theme: {
            extend: {
              colors: {
                neonPurple: '#b026ff',
                neonGreen: '#00ff9d',
                neonBlue: '#00f3ff',
                darkBg: '#050510',
                panel: 'rgba(20, 20, 40, 0.6)',
              },
              boxShadow: {
                'glow-purple': '0 0 20px rgba(176, 38, 255, 0.5), inset 0 0 10px rgba(176, 38, 255, 0.2)',
                'glow-green': '0 0 20px rgba(0, 255, 157, 0.5), inset 0 0 10px rgba(0, 255, 157, 0.2)',
              },
              animation: {
                'float': 'float 6s ease-in-out infinite',
                'pulse-neon': 'pulseNeon 2s ease-in-out infinite',
              },
              keyframes: {
                float: {
                  '0%, 100%': { transform: 'translateY(0)' },
                  '50%': { transform: 'translateY(-10px)' },
                },
                pulseNeon: {
                  '0%, 100%': { filter: 'drop-shadow(0 0 5px rgba(0, 243, 255, 0.5))' },
                  '50%': { filter: 'drop-shadow(0 0 15px rgba(0, 243, 255, 0.8))' },
                }
              }
            }
          }
        }
      </script>
    
    <!-- Solana Web3 -->
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>

    <style>
        body {
            background-color: #050510;
            color: white;
            font-family: 'Inter', sans-serif;
            overflow-x: hidden;
            margin: 0;
        }

        /* Particle Background */
        .particles {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-image: 
                radial-gradient(circle at 50% 50%, rgba(176, 38, 255, 0.1) 0%, transparent 50%),
                radial-gradient(white 1px, transparent 1px);
            background-size: 100% 100%, 50px 50px;
            opacity: 0.5;
            z-index: -1;
            animation: moveBackground 100s linear infinite;
        }

        @keyframes moveBackground {
            from { background-position: 0 0, 0 0; }
            to { background-position: 0 0, 1000px 1000px; }
        }

        .wheel-container {
            transition: transform 6s cubic-bezier(0.1, 0.8, 0.1, 1);
            will-change: transform;
        }

        .glass-panel {
            background: rgba(20, 25, 40, 0.7);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        /* Segment Text Orientation */
        .segment-text-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
        }
        
        .segment-label {
            position: absolute;
            top: 20px; left: 50%;
            transform: translateX(-50%);
            text-align: center;
            transform-origin: center bottom;
        }

    </style>
</head>
<body>

    <div id="root"></div>

    <div class="particles"></div>

    <script type="text/babel">
        const { Connection, PublicKey, Transaction, SystemProgram, clusterApiUrl, LAMPORTS_PER_SOL } = solanaWeb3;

        // --- CONFIGURATION ---
        // Using 'confirmed' commitment helps with "Network Busy" errors by accepting slightly less finality
        const CONNECTION_CONFIG = { commitment: 'confirmed', confirmTransactionInitialTimeout: 60000 };
        const SOLANA_NETWORK = 'mainnet-beta'; 
        const SPIN_COST = 0.01; 
        const HOUSE_ADDRESS = "CTD6awXNUksKhCFcZX8Ubst2ANxioUUNX1iRbhTYKxby";

        const SEGMENTS = [
            { label: "2 SOL",   value: 2,    color: "#FFD700", textColor: "#000", type: "win", weight: 0 },
            { label: "LOST",    value: 0,    color: "#EF4444", textColor: "#FFF", type: "lose", weight: 15 },
            { label: "0.1 SOL", value: 0.1,  color: "#8B5CF6", textColor: "#FFF", type: "win", weight: 10 },
            { label: "EMPTY",   value: 0,    color: "#64748B", textColor: "#FFF", type: "lose", weight: 10 },
            { label: "1 SOL",   value: 1,    color: "#F59E0B", textColor: "#000", type: "win", weight: 0 },
            { label: "AGAIN",   value: 0,    color: "#DC2626", textColor: "#FFF", type: "lose", weight: 15 },
            { label: "0.05 SOL", value: 0.05, color: "#10B981", textColor: "#FFF", type: "win", weight: 15 },
            { label: "BAD LUCK", value: 0,   color: "#475569", textColor: "#FFF", type: "lose", weight: 5 },
            { label: "0.5 SOL", value: 0.5,  color: "#3B82F6", textColor: "#FFF", type: "win", weight: 5 },
            { label: "NO LUCK", value: 0,    color: "#7F1D1D", textColor: "#FFF", type: "lose", weight: 10 },
            { label: "5 SOL",   value: 5,    color: "#EC4899", textColor: "#FFF", type: "win", weight: 0 },
            { label: "BANKRUPT", value: 0,   color: "#1E293B", textColor: "#FFF", type: "lose", weight: 15 },
        ];

        const SEGMENT_ANGLE = 360 / SEGMENTS.length;

        // Retry Utility
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
        
        async function withRetry(fn, retries = 3, delay = 1000) {
            try {
                return await fn();
            } catch (err) {
                if (retries <= 1) throw err;
                console.log(`Retrying... attempts left: ${retries - 1}`);
                await sleep(delay);
                return withRetry(fn, retries - 1, delay * 1.5);
            }
        }

        // Sound Engine
        const AudioEngine = {
            ctx: null,
            init: function() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
            },
            click: function() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.05);
                gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.05);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.05);
            },
            win: function() {
                if (!this.ctx) return;
                const now = this.ctx.currentTime;
                [261.63, 329.63, 392.00, 523.25].forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'triangle';
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0.1, now + i * 0.1);
                    gain.gain.linearRampToValueAtTime(0, now + i * 0.1 + 0.5);
                    osc.connect(gain);
                    gain.connect(this.ctx.destination);
                    osc.start(now + i * 0.1);
                    osc.stop(now + i * 0.1 + 0.5);
                });
            }
        };

        const getProvider = () => {
            if ('phantom' in window) {
                const provider = window.phantom?.solana;
                if (provider?.isPhantom) return provider;
            }
            return window.solana?.isPhantom ? window.solana : null;
        };

        function App() {
            const [walletAddress, setWalletAddress] = React.useState(null);
            const [balance, setBalance] = React.useState(null); 
            const [isSpinning, setIsSpinning] = React.useState(false);
            const [rotation, setRotation] = React.useState(0);
            const [status, setStatus] = React.useState({ type: 'info', msg: 'Connect wallet to play' });
            const [history, setHistory] = React.useState([]);
            const [soundEnabled, setSoundEnabled] = React.useState(true);

            // Connection with retry-friendly config
            const connection = new Connection(clusterApiUrl(SOLANA_NETWORK), CONNECTION_CONFIG);

            const connectWallet = async () => {
                const provider = getProvider();
                if (provider) {
                    try {
                        const resp = await provider.connect();
                        const pubKey = resp.publicKey.toString();
                        setWalletAddress(pubKey);
                        setStatus({ type: 'success', msg: 'Connected! Ready to spin.' });
                        AudioEngine.init();
                        fetchBalance(resp.publicKey);
                    } catch (err) {
                        setStatus({ type: 'error', msg: 'Connection rejected' });
                    }
                } else {
                    window.open("https://phantom.app/", "_blank");
                }
            };

            const fetchBalance = async (publicKey) => {
                try {
                    const bal = await connection.getBalance(publicKey);
                    setBalance(bal / LAMPORTS_PER_SOL);
                } catch (err) {
                    console.error("Balance fetch error:", err);
                }
            };

            const handleSpin = async () => {
                if (!walletAddress || isSpinning) return;
                
                // Initialize audio context on user interaction if needed
                AudioEngine.init();

                const provider = getProvider();
                if (!provider) return;

                // Local balance check (optional, good UX)
                if (balance !== null && balance < SPIN_COST) {
                    setStatus({ type: 'error', msg: `Insufficient funds (${SPIN_COST} SOL)` });
                    return;
                }

                setStatus({ type: 'process', msg: 'Preparing transaction...' });

                try {
                    const sender = new PublicKey(walletAddress);
                    const receiver = new PublicKey(HOUSE_ADDRESS); 

                    // 1. Get Blockhash (with Retry)
                    let blockhashData;
                    try {
                        blockhashData = await withRetry(() => connection.getLatestBlockhash('finalized'));
                    } catch (e) {
                        console.error("RPC Error:", e);
                        setStatus({ type: 'error', msg: 'Network Busy. Please try again.' });
                        return;
                    }

                    const transaction = new Transaction({
                        recentBlockhash: blockhashData.blockhash,
                        feePayer: sender
                    }).add(
                        SystemProgram.transfer({
                            fromPubkey: sender,
                            toPubkey: receiver, 
                            lamports: Math.round(SPIN_COST * LAMPORTS_PER_SOL),
                        })
                    );

                    // 2. User Sign (No retry here, user action)
                    setStatus({ type: 'process', msg: 'Please approve in wallet...' });
                    const signedTransaction = await provider.signTransaction(transaction);
                    
                    // 3. Send Raw Transaction (with Retry)
                    setStatus({ type: 'process', msg: 'Broadcasting...' });
                    const signature = await withRetry(async () => {
                        return await connection.sendRawTransaction(signedTransaction.serialize(), {
                            skipPreflight: false,
                            preflightCommitment: 'confirmed'
                        });
                    });

                    setStatus({ type: 'process', msg: 'Spinning! ðŸŽ¡' });
                    startWeightedSpin();
                    
                    // Update balance in background
                    setTimeout(() => fetchBalance(sender), 4000);

                } catch (error) {
                    console.error("Tx Error:", error);
                    if (error.message?.includes("User rejected")) {
                        setStatus({ type: 'error', msg: 'Transaction Cancelled' });
                    } else if (error.message?.includes("0x1")) {
                        setStatus({ type: 'error', msg: 'Insufficient Funds' });
                    } else {
                        setStatus({ type: 'error', msg: 'Network Congestion. Try again.' });
                    }
                }
            };

            const startWeightedSpin = () => {
                setIsSpinning(true);
                
                const totalWeight = SEGMENTS.reduce((sum, seg) => sum + seg.weight, 0);
                let randomNum = Math.random() * totalWeight;
                let selectedIndex = 0;
                for (let i = 0; i < SEGMENTS.length; i++) {
                    if (randomNum < SEGMENTS[i].weight) {
                        selectedIndex = i;
                        break;
                    }
                    randomNum -= SEGMENTS[i].weight;
                }

                // Math for 12 segments
                // To land on index i, we need angle: 360 - (i * 30 + 15)
                const segmentCenter = selectedIndex * SEGMENT_ANGLE + (SEGMENT_ANGLE / 2); 
                const stopAngle = 360 - segmentCenter; 
                
                // Add fuzziness (+/- 12 deg) to stay safely inside the 30 deg segment
                const fuzziness = (Math.random() - 0.5) * 24; 
                
                const extraSpins = 360 * 6; // 6 full spins
                const targetRotation = rotation + extraSpins + (stopAngle - (rotation % 360)) + fuzziness;
                
                // Ensure forward rotation only
                const finalRotation = Math.max(targetRotation, rotation + 360 * 5); 

                setRotation(finalRotation);

                // Sound Loop
                if (soundEnabled) {
                     let count = 0;
                     const totalTicks = 40;
                     const interval = setInterval(() => {
                        AudioEngine.click();
                        count++;
                        if(count >= totalTicks) clearInterval(interval);
                     }, 6000 / totalTicks);
                }

                setTimeout(() => {
                    setIsSpinning(false);
                    calculateResult(selectedIndex);
                }, 6000);
            };

            const calculateResult = (index) => {
                const result = SEGMENTS[index];
                setHistory(prev => [result, ...prev].slice(0, 4)); // Keep last 4

                if (result.type === 'win') {
                    setStatus({ type: 'win', msg: `WIN: ${result.label}` });
                    if(soundEnabled) AudioEngine.win();
                    confetti({
                        particleCount: 150,
                        spread: 70,
                        origin: { y: 0.6 },
                        colors: ['#00ff9d', '#b026ff', '#ffffff']
                    });
                } else {
                    setStatus({ type: 'lose', msg: result.label });
                }
            };

            return (
                <div className="flex flex-col items-center justify-center min-h-screen relative overflow-hidden">
                    
                    {/* UI Header */}
                    <div className="absolute top-6 w-full max-w-lg px-4 z-20">
                        <div className="glass-panel rounded-2xl p-4 flex justify-between items-center shadow-glow-purple">
                            <div className="flex items-center gap-3">
                                <div className="w-10 h-10 bg-gradient-to-br from-neonPurple to-neonBlue rounded-xl flex items-center justify-center shadow-lg animate-float">
                                    <span className="text-xl font-bold text-white">â—Ž</span>
                                </div>
                                <div>
                                    <h1 className="text-xl font-black text-white leading-none tracking-tight">SOLANA</h1>
                                    <span className="text-xs font-bold text-neonGreen tracking-[0.3em]">SPIN</span>
                                </div>
                            </div>
                            
                            {!walletAddress ? (
                                <button onClick={connectWallet} className="bg-gradient-to-r from-neonPurple to-blue-600 hover:to-neonPurple text-white px-5 py-2 rounded-xl font-bold transition-all shadow-lg hover:shadow-neonPurple/50 text-sm">
                                    Connect
                                </button>
                            ) : (
                                <div className="flex items-center gap-3">
                                    <div className="text-right px-3 py-1 bg-black/40 rounded-lg border border-white/10">
                                        <div className="text-[9px] text-gray-400 font-bold uppercase tracking-wider">Balance</div>
                                        <div className="font-mono text-neonGreen font-bold text-sm leading-none">
                                            {balance === null ? "..." : balance.toFixed(3)}
                                        </div>
                                    </div>
                                    <button onClick={() => setSoundEnabled(!soundEnabled)} className="w-9 h-9 flex items-center justify-center bg-white/5 hover:bg-white/10 rounded-lg text-gray-300 hover:text-white transition border border-white/10">
                                        {soundEnabled ? "ðŸ”Š" : "ðŸ”‡"}
                                    </button>
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Wheel Area */}
                    <div className="relative z-10 scale-[0.85] sm:scale-100 mt-10">
                        
                        {/* Metallic Needle */}
                        <div className="absolute -top-14 left-1/2 transform -translate-x-1/2 z-30 drop-shadow-xl pointer-events-none">
                            <div className="w-4 h-12 bg-gradient-to-b from-yellow-100 to-yellow-600 rounded-t-sm"></div>
                            <div className="w-0 h-0 border-l-[10px] border-l-transparent border-r-[10px] border-r-transparent border-t-[24px] border-t-yellow-600 -mt-1"></div>
                        </div>

                        {/* Outer Glow Ring */}
                        <div className="absolute -inset-6 rounded-full border-2 border-neonPurple/30 shadow-[0_0_60px_rgba(176,38,255,0.3)] z-0 animate-pulse-neon"></div>
                        
                        {/* The Wheel */}
                        <div className="w-[340px] h-[340px] sm:w-[400px] sm:h-[400px] rounded-full border-[8px] border-slate-800 overflow-hidden shadow-[inset_0_0_60px_rgba(0,0,0,0.8)] bg-[#1a1a1a] relative z-10">
                            <div 
                                className="w-full h-full rounded-full wheel-container"
                                style={{ 
                                    transform: `rotate(${rotation}deg)`,
                                    background: `conic-gradient(
                                        ${SEGMENTS[0].color} 0deg 30deg,
                                        ${SEGMENTS[1].color} 30deg 60deg,
                                        ${SEGMENTS[2].color} 60deg 90deg,
                                        ${SEGMENTS[3].color} 90deg 120deg,
                                        ${SEGMENTS[4].color} 120deg 150deg,
                                        ${SEGMENTS[5].color} 150deg 180deg,
                                        ${SEGMENTS[6].color} 180deg 210deg,
                                        ${SEGMENTS[7].color} 210deg 240deg,
                                        ${SEGMENTS[8].color} 240deg 270deg,
                                        ${SEGMENTS[9].color} 270deg 300deg,
                                        ${SEGMENTS[10].color} 300deg 330deg,
                                        ${SEGMENTS[11].color} 330deg 360deg
                                    )`
                                }}
                            >
                                {/* Segments Rendering */}
                                {SEGMENTS.map((seg, i) => (
                                    <React.Fragment key={i}>
                                        <div className="absolute top-0 left-1/2 w-[1px] h-1/2 bg-white/20 origin-bottom transform -translate-x-1/2" style={{ transform: `rotate(${i * 30}deg)` }}></div>
                                        
                                        <div 
                                            className="segment-text-container"
                                            style={{ transform: `rotate(${i * 30 + 15}deg)` }}
                                        >
                                            <div className="segment-label">
                                                <div 
                                                    className="font-black text-[11px] sm:text-[13px] uppercase tracking-wider drop-shadow-md whitespace-nowrap"
                                                    style={{ 
                                                        color: seg.textColor,
                                                        writingMode: 'vertical-rl',
                                                        textOrientation: 'mixed',
                                                        transform: 'rotate(180deg)',
                                                        marginTop: '20px'
                                                    }}
                                                >
                                                    {seg.label}
                                                </div>
                                            </div>
                                        </div>
                                    </React.Fragment>
                                ))}
                            </div>
                            
                            {/* Inner Shine */}
                            <div className="absolute inset-0 rounded-full bg-gradient-to-tr from-white/10 to-transparent pointer-events-none"></div>

                            {/* Center Hub */}
                            <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-16 h-16 bg-gradient-to-br from-gray-800 to-black rounded-full flex items-center justify-center border-2 border-neonBlue shadow-glow-green z-20">
                                <span className="text-xl animate-pulse">ðŸ’ </span>
                            </div>
                        </div>
                    </div>

                    {/* Status Display */}
                    <div className={`mt-8 mb-4 px-6 py-3 rounded-xl border text-center font-bold text-sm w-full max-w-xs transition-all duration-300 shadow-xl z-20 backdrop-blur-md ${
                        status.type === 'error' ? 'bg-red-900/80 border-red-500/50 text-red-100' :
                        status.type === 'win' ? 'bg-neonGreen/20 border-neonGreen text-neonGreen' :
                        status.type === 'process' ? 'bg-blue-900/80 border-blue-500/50 text-blue-100 animate-pulse' :
                        'bg-white/5 border-white/10 text-gray-300'
                    }`}>
                        {status.msg}
                    </div>

                    {/* Main Button */}
                    <button 
                        onClick={handleSpin}
                        disabled={!walletAddress || isSpinning}
                        className={`
                            relative w-64 h-16 rounded-full font-black text-xl transition-all duration-200 transform z-20
                            ${!walletAddress 
                                ? 'bg-gray-800 text-gray-500 cursor-not-allowed border border-gray-700' 
                                : isSpinning 
                                    ? 'bg-gray-700 text-gray-400 cursor-wait border border-gray-600'
                                    : 'bg-gradient-to-r from-neonPurple to-neonBlue hover:scale-105 text-white shadow-glow-purple active:scale-95 hover:shadow-glow-green border-t border-white/30'
                            }
                        `}
                    >
                        <span className="flex items-center justify-center gap-2 drop-shadow-md">
                            {isSpinning ? 'SPINNING...' : `SPIN ${SPIN_COST} SOL`}
                        </span>
                    </button>
                    
                    {/* History Strip */}
                    {history.length > 0 && (
                        <div className="mt-6 flex gap-2 z-10 opacity-80">
                            {history.map((h, i) => (
                                <div key={i} className={`
                                    w-8 h-8 rounded flex items-center justify-center text-[10px] font-bold border transition-all
                                    ${h.type === 'win' ? 'bg-neonGreen/20 border-neonGreen text-neonGreen' : 'bg-red-500/20 border-red-500 text-red-400'}
                                `}>
                                    {h.type === 'win' ? 'W' : 'L'}
                                </div>
                            ))}
                        </div>
                    )}
                    
                    <div className="absolute bottom-4 text-[10px] text-gray-600 font-medium uppercase tracking-[0.2em] opacity-50">
                         SOLANA MAINNET
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
